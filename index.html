<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ANNICK BOUVATTIER</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="styles.css" />

  <style>
    body.home{
      background-image:none !important;
      background:#02253A !important;
      overflow:hidden;
    }

    .page{min-height:100vh;display:flex;flex-direction:column;}
    .container{flex:1;display:flex;flex-direction:column;position:relative;z-index:3;}

    .galleryWall{
      position:fixed;
      inset:0;
      z-index:1;
      pointer-events:none;
      background:
        radial-gradient(1100px 700px at 20% 15%, rgba(255,255,255,.12), rgba(255,255,255,0) 60%),
        radial-gradient(900px 600px at 70% 70%, rgba(255,255,255,.10), rgba(255,255,255,0) 55%);
    }

    .viewport{
      position:absolute;
      inset:0;
      overflow:hidden;
    }

    .row{
      position:absolute;
      top:50%;
      left:0;
      display:flex;
      align-items:center;
      transform: translate3d(0,-50%,0);
      will-change: transform;
      white-space: nowrap;
      padding: 0 60px;
      gap: 0; /* gap est géré dans les bands */
    }
    @media (max-width: 900px){
      .row{ padding: 0 28px; }
    }

    /* ✅ band = une boucle mesurable */
    .band{
      display:inline-flex;
      align-items:center;
      gap:42px; /* ✅ écart identique */
    }

    /* ✅ gap entre les bandes (entre left/center/right) */
.row { column-gap: 42px; }           /* même valeur que .band gap */
@media (max-width: 900px){
  .row { column-gap: 28px; }
}

    @media (max-width: 900px){
      .band{ gap:28px; }
    }

    .piece{
  flex: 0 0 auto;
  height: var(--h, min(62vh, 560px));  /* ✅ hauteur par tableau */
  width:  var(--w, 360px);            /* ✅ largeur par tableau */
  position: relative;
    }

    .piece::before{
      content:"";
      position:absolute;
      left:50%;
      top:-18%;
      width: 150%;
      height: 70%;
      transform: translateX(-50%);
      background: radial-gradient(closest-side, rgba(255,255,255,.22), rgba(255,255,255,0) 72%);
      opacity: .85;
      pointer-events:none;
      filter: blur(1px);
    }

    .frame{
  position:relative;
  width:100%;
  height:100%;
  background:#0b1520;
  border: 10px solid rgba(255,255,255,.10);
  outline: 1px solid rgba(255,255,255,.18);
  box-shadow: 0 24px 70px rgba(0,0,0,.45), inset 0 0 0 2px rgba(0,0,0,.35);
  overflow:hidden;
}

.art{ position:absolute; inset:0; }

.art img{
  width:100%;
  height:100%;
  object-fit: contain;   /* ✅ pas de bandes si ratio exact */
  display:block;
}

    .frame::after{
      content:"";
      position:absolute;
      inset:0;
      background:
        radial-gradient(120% 90% at 50% 35%, rgba(255,255,255,.10), rgba(0,0,0,.18) 70%),
        linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,.18));
      opacity:.22;
      pointer-events:none;
    }

    .top, .bottom{position:relative;z-index:4;}
    .bottom{margin-top:auto;padding-bottom:18px;}

    @media (prefers-reduced-motion: reduce){
      .galleryWall{display:none;}
      body.home{overflow:auto;}
    }
  </style>
</head>

<body class="home">
  <div class="galleryWall" aria-hidden="true">
    <div class="viewport">
      <div class="row" id="row"></div>
    </div>
  </div>

  <div class="page">
    <div class="container">
      <header class="top">
        <div class="top__left">
          <a href="index.html" class="brand" aria-label="Accueil">ANNICK&nbsp;BOUVATTIER</a>
        </div>
        <nav class="top__nav" aria-label="Navigation principale">
          <a class="nav__link is-active" href="index.html">Accueil</a>
          <a class="nav__link" href="portfolio.html">Portfolio</a>
          <a class="nav__link" href="galeries.html">Galeries</a>
          <a class="nav__link" href="expositions.html">Expositions</a>
          <a class="nav__link" href="apropos.html">À propos</a>
          <a class="nav__link" href="presse.html">Presse</a>
          <a class="nav__link" href="contact.html">Contact</a>
        </nav>
      </header>

      <footer class="bottom">
        <div class="bottom__left">
          <a class="bottom__link" href="https://www.instagram.com/annick.bouvattier/" target="_blank" rel="noopener noreferrer">instagram</a>
          <a class="bottom__link" href="https://www.facebook.com/annick.bouvattier/" target="_blank" rel="noopener noreferrer">facebook</a>
          <a class="bottom__link" href="https://www.saatchiart.com/bouvattier" target="_blank" rel="noopener noreferrer">saatchi art</a>
        </div>
      </footer>
    </div>
  </div>
  
<script>
(() => {
  "use strict";

  // ✅ même source que portfolio.html
  const SHEET_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSmK-RAKlpq_VMnhd78eWdWeMTnCkU3_-411IzeTyzO9j0zbJdkkhzfxlRDZpqzKixpoUgTtAAI_Auw/pub?output=csv";
  const IMG_BASE = "images/";   // portfolio: const IMG_BASE="images"

  const BORDER_PX = 10;         // .frame { border: 10px }
  const GAP_DESKTOP = 42;
  const GAP_MOBILE  = 28;

  const row = document.getElementById("row");
  if (!row) return;

  const prefersReducedMotion =
    window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

  function currentGap(){
    return window.innerWidth <= 900 ? GAP_MOBILE : GAP_DESKTOP;
  }

  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }

  // CSV robuste (copié/simplifié de ton portfolio)
  function parseCSV(text){
    const rows = [];
    let row = [];
    let value = "";
    let inQuotes = false;

    for(let i=0;i<text.length;i++){
      const c = text[i];
      const next = text[i+1];

      if(c === '"' && next === '"'){
        value += '"';
        i++;
        continue;
      }
      if(c === '"'){
        inQuotes = !inQuotes;
        continue;
      }
      if(c === "," && !inQuotes){
        row.push(value.trim());
        value = "";
        continue;
      }
      if((c === "\n" || c === "\r") && !inQuotes){
        if(value.length || row.length){
          row.push(value.trim());
          rows.push(row);
          row = [];
          value = "";
        }
        continue;
      }
      value += c;
    }

    if(value.length || row.length){
      row.push(value.trim());
      rows.push(row);
    }

    return rows;
  }

  function normalizeHeader(h){
    return String(h ?? "")
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .trim();
  }

  function normSize(s){
    return String(s ?? "")
      .toLowerCase()
      .replaceAll("×","x")
      .replace(/\s+/g," ")
      .replace(/\s*x\s*/g," x ")
      .replace(/\s*cm\s*/g," cm")
      .trim();
  }

  function parseDims(sizeStr){
    const s = normSize(sizeStr);
    const m = s.match(/(\d+(?:[.,]\d+)?)\s*x\s*(\d+(?:[.,]\d+)?)/i);
    if(!m) return null;
    const a = parseFloat(m[1].replace(",", "."));
    const b = parseFloat(m[2].replace(",", "."));
    if(!isFinite(a) || !isFinite(b)) return null;
    // on ne sait pas si sheet = "H x L" ou "L x H"
    // on prend max = hauteur “mur”, min = largeur, ça évite les inversions trop visibles
    return { w: Math.min(a,b), h: Math.max(a,b) };
  }

  function buildImagePath(jpg){
    let p = String(jpg || "").trim();
    p = p.replace(/^images\//i, "");
    p = p.replace(/^\/+/, "");
    return IMG_BASE + encodeURI(p);
  }

  async function loadArtworksFromSheet(){
    const res = await fetch(SHEET_CSV_URL, { cache: "no-store" });
    if(!res.ok) throw new Error("Sheet KO: " + res.status);

    const csv = await res.text();
    const rows = parseCSV(csv);

    const header = rows.shift().map(normalizeHeader);
    const col = (name) => header.indexOf(normalizeHeader(name));

    // colonnes attendues: Nom | Année | Catégorie | Technique | Format | Disponible | Jpg
    const idxJpg = col("jpg");
    const idxFmt = col("format");
    const idxNom = col("nom");

    const out = rows
      .filter(r => r[idxNom] && r[idxJpg])
      .map(r => {
        const jpg = r[idxJpg];
        const fmt = r[idxFmt] || "";
        const dims = parseDims(fmt); // {w,h} en cm (approx)
        return {
          src: buildImagePath(jpg),
          dimsCm: dims,         // peut être null
        };
      })
      .filter(x => x.src);

    if(!out.length) throw new Error("Aucune image dans la Sheet");
    return out;
  }

  function makePiece(src){
    const piece = document.createElement("div");
    piece.className = "piece";

    const frame = document.createElement("div");
    frame.className = "frame";

    const art = document.createElement("div");
    art.className = "art";

    const img = document.createElement("img");
    img.alt = "";
    img.loading = "eager";
    img.decoding = "async";
    img.src = src;

    art.appendChild(img);
    frame.appendChild(art);
    piece.appendChild(frame);

    img.addEventListener("error", () => piece.remove(), { once:true });

    return { piece, img };
  }

  function waitImageReady(img){
    if (img.decode) return img.decode().catch(() => {});
    return new Promise((resolve) => {
      if (img.complete) return resolve();
      img.addEventListener("load", resolve, { once:true });
      img.addEventListener("error", resolve, { once:true });
    });
  }

  function buildBands(pieces){
    const bandL = document.createElement("div");
    const bandC = document.createElement("div");
    const bandR = document.createElement("div");
    bandL.className = "band";
    bandC.className = "band";
    bandR.className = "band";

    pieces.forEach((p, i) => {
      (i % 3 === 0 ? bandL : i % 3 === 1 ? bandC : bandR).appendChild(p);
    });

    row.innerHTML = "";
    row.appendChild(bandL);
    row.appendChild(bandC);
    row.appendChild(bandR);

    // clone pour boucle infinie
    row.appendChild(bandL.cloneNode(true));
    row.appendChild(bandC.cloneNode(true));
    row.appendChild(bandR.cloneNode(true));

    return { bandL, bandC, bandR };
  }

  function measureLoopWidth(){
    const bands = row.querySelectorAll(".band");
    if (bands.length < 3) return 0;
    return (
      bands[0].getBoundingClientRect().width +
      bands[1].getBoundingClientRect().width +
      bands[2].getBoundingClientRect().width +
      currentGap() * 2
    );
  }

  // ✅ mapping tailles cm -> px (proportions relatives)
  function computeHeightPxFromCm(artworks){
    // on prend la “hauteur cm” si dispo, sinon fallback 100
    const hs = artworks.map(a => (a.dimsCm?.h ?? 100)).filter(Boolean);
    const minCm = Math.min(...hs);
    const maxCm = Math.max(...hs);

    // bornes mur (tu peux ajuster)
    const MIN_PX = 260;
    const MAX_PX = Math.min(560, Math.floor(window.innerHeight * 0.62));

    return (hCm) => {
      const h = (hCm ?? 100);
      if (maxCm === minCm) return MAX_PX;
      const t = (h - minCm) / (maxCm - minCm);
      const px = MIN_PX + t * (MAX_PX - MIN_PX);
      return Math.round(px);
    };
  }

  async function init(){
    if (prefersReducedMotion) return;

    const all = shuffle(await loadArtworksFromSheet());

    // assez d'items pour que la boucle soit fluide
    const approxPerScreen = Math.ceil(window.innerWidth / 260) + 12;
    const count = Math.max(24, approxPerScreen * 2);

    const picked = [];
    for(let i=0;i<count;i++){
      picked.push(all[i % all.length]);
    }

    const heightFromCm = computeHeightPxFromCm(picked);

    const pieces = [];
    const imgs = [];

    for (const a of picked){
      const { piece, img } = makePiece(a.src);

      // hauteur proportionnelle aux cm
      const hPx = heightFromCm(a.dimsCm?.h);
      piece.style.setProperty("--h", hPx + "px");

      pieces.push(piece);
      imgs.push(img);
    }

    buildBands(pieces);

    // attendre une frame
    await new Promise(r => requestAnimationFrame(r));

    // attendre images prêtes
    await Promise.all(imgs.map(waitImageReady));

    // largeur selon ratio image + hauteur choisie (en px)
    pieces.forEach((piece, i) => {
      const img = imgs[i];
      if (!img.naturalWidth || !img.naturalHeight) return;

      const hOuter = parseFloat(getComputedStyle(piece).height);
      const hInner = Math.max(1, hOuter - BORDER_PX * 2);
      const ratio = img.naturalWidth / img.naturalHeight;

      const wInner = hInner * ratio;
      const wOuter = wInner + BORDER_PX * 2;

      piece.style.setProperty("--w", Math.round(Math.max(240, wOuter)) + "px");
    });

    // reflow
    await new Promise(r => requestAnimationFrame(r));

    let loopW = measureLoopWidth();
    if (!loopW) return;

    // départ hors écran à gauche
    let x = -loopW;
    const speed = 70;
    let last = performance.now();

    function tick(now){
      const dt = Math.min(0.05, (now - last)/1000);
      last = now;

      x += speed * dt;
      if (x >= 0) x -= loopW;

      row.style.transform = `translate3d(${x}px, -50%, 0)`;
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    window.addEventListener("resize", () => location.reload());
  }

  init().catch(err => console.error("[home-wall]", err));
})();
</script>

  
</body>
</html>
